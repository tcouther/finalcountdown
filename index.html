<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
	<title>FinalCounterDown</title>
	<style>
		body {
			font-family: arial;
			font-size: 18px;
		}
		.bytecount {
			color: #777;
			padding: 10px 0px;
			margin: 10px 0;
			display: inline-block;
			position: relative;
		}
		.bytecount span {
			display: inline-block;
			overflow: hidden;
		}
		.bytecount span+span {
			padding-left: 5px;
			transition: opacity 1s ease-in-out;
   			-moz-transition: opacity 1s ease-in-out;
   			-webkit-transition: opacity 1s ease-in-out;
		}
		.bytecount[data-countdown-animate^='true'] span+span {
			opacity: 0;
		}
		.bug {
			border: 1px solid #CCC;
			padding: 10px;
		}
		.bug h3 {
			margin: 0;
		}
		.bug p {
			margin: 0;
		}
	</style>
</head>
<body>
	<header>
		<h1>FinalCounterDown</h1>
		<p>Light-weight, animated counter changes a number from old value to the new value with formatting, and easing options.</p>

		<div class="bytecount" data-countdown-init="true" data-current-number="1" data-new-number="9000000000">
			<span>0.00</span><span>B</span>
		</div>

		<div class="bug">
			<h3>Bugs</h3>
			<p>Fixed Everything. Just trying to make it more performant and add features while keeping it light.</p>
		</div>
	</header>

<script>
	/*
		Counter with formatting options
		By Terrill Couther
	*/

	var CountDown = function(options) {
		this.el = options.element || null;
		let elCurrentValue = this.el.getAttribute('data-current-number');
		let elNewValue = this.el.getAttribute('data-new-number');

		this.curNum = options.curNum || parseInt(elCurrentValue) || 0;
		this.newNum = options.newNum || parseInt(elNewValue) || 0;
		this.easing = options.easing || null;
		this.format = options.format || null;
		this.runtime = options.runtime || 3;
		this.idelay = options.idelay || null;
		this.cntNum = this.curNum;
		this.decimals = options.decimal || 2;
		this.events = {};
		this.displayTarget = '';

		this.setEvents();
	};

	CountDown.prototype.init = function() {
		this.el.dispatchEvent(this.events.eventCountdownInit);

		if ( this.el && this.el.getAttribute('data-countdown-init') ) {
			let countIt = function(){
				this.countStart({'newNum' : this.newNum});
			}.bind(this);

			let idelay = this.idelay;
			if ( idelay ) {
				window.setTimeout(countIt,idelay);
			} else {
				countIt();
			}
		}
	};
	CountDown.prototype.setEvents = function(){
		//set custom events
		this.events.eventCountdownInit = new Event('eventCountdownInit');
		this.events.eventCountdownStart = new Event('eventCountdownStart');
		this.events.eventCountdownStop = new Event('eventCountdownStop');
		this.events.eventCountdownChange = new Event('eventCountdownChange');

		this.el.addEventListener('eventCountdownStart', function(evt) {
			this.el.setAttribute('data-countdown-animate',true);
		}.bind(this), false);
		this.el.addEventListener('eventCountdownStop', function(evt) {
			this.el.setAttribute('data-countdown-animate',false);
		}.bind(this), false);
	};
	CountDown.prototype.numDiff = function(num1, num2){
		return (num1 > num2) ? num1-num2 : num2-num1;
	};
	CountDown.prototype.displayNumber = function(num) {
		let value = num || this.cntNum;
		let frmat = this.format || null;
		let decimals = this.decimals;
		let displayed = (frmat) ? this.formatNum[frmat](value,decimals) : value;
		if (this.el) {
			this.el.innerHTML = displayed;
			//trigger change
			this.el.dispatchEvent(this.events.eventCountdownChange);
		}
		return displayed;
	};
	CountDown.prototype.easeOutX = function(t, b, c, d) {
		return c * (-Math.pow(2, -10 * t / d) + 1) * 1024 / 1023 + b;
	};
	CountDown.prototype.countAnimate = function() {
		if ( this.stop == null ) {
			this.timestamp = Date.now();
			let diffCurNew = this.numDiff(this.curNum,this.newNum);
			let display = '';
			let timeElampsed = this.timestamp - this.startTime;

			if ( this.easing ) {
				if (this.dirNum == -1) {

					console.log(this.easeOutX(timeElampsed, 0, diffCurNew, this.duration))
					this.cntNum = this.curNum - this.easeOutX(timeElampsed, 0, diffCurNew, this.duration);

				} else {
					console.log(this.easeOutX(timeElampsed, this.curNum, diffCurNew, this.duration));
					this.cntNum = this.easeOutX(timeElampsed, this.curNum, diffCurNew, this.duration);
				}
			} else {
				if (this.dirNum == -1) {
					this.cntNum = this.curNum - (this.curNum * (timeElampsed / this.duration));
				} else {
					this.cntNum = this.curNum + (this.curNum * (timeElampsed / this.duration));
				}
			}

			//Limit
			if (this.dirNum == -1) {
				this.cntNum = (this.cntNum <= this.newNum) ? this.newNum : this.cntNum;
			} else {
				this.cntNum = (this.cntNum >= this.newNum) ? this.newNum : this.cntNum;
			}

			//display Number
			display = this.displayNumber();

			// whether to stop
			if (timeElampsed >= this.duration) {
				this.stop = true;
			}

			//one more time =)
			window.requestAnimationFrame(this.countAnimateBound);
		} else {
			this.countStop();
		}
	};
	CountDown.prototype.countStop = function(display) {
		this.stop = true;
		this.cntNum = this.newNum;
		this.curNum = this.newNum;

		if ( this.el ) {
			this.el.setAttribute('data-current-number',this.newNum);
			this.el.setAttribute('data-new-number',this.newNum);
			if ( display ) this.displayNumber();
		}

		//trigger stop
		this.el.dispatchEvent(this.events.eventCountdownStop);
	};
	CountDown.prototype.countStart = function(options) {
		this.newNum = options.newNum || this.newNum || 0;
		this.dirNum = (this.curNum < this.newNum) ? 1 : -1;
		this.stop = null;
		this.stopped = null;
		this.displayTarget = this.formatNum[this.format](this.newNum,this.decimals);
		this.countAnimateBound = this.countAnimate.bind(this);
		this.duration = Number(this.runtime) * 1000 || 2000;
		this.startTime = this.timestamp = Date.now();
		this.el.dispatchEvent(this.events.eventCountdownStart);
		//start animation
		this.countAnimate();
	};
	CountDown.prototype.formatNum = {
		'decimals' : function(a,b) {
			return parseFloat(a.toFixed(b))
		},
		'bytes1024Txt' : function(a,b) {if(0==a)return"0 Bytes";var c=1024,d=b||2,e=["Bytes","KB","MB","GB","TB","PB","EB","ZB","YB"],f=Math.floor(Math.log(a)/Math.log(c));return parseFloat((a/Math.pow(c,f)).toFixed(d))+" "+e[f]
		},
		'bytes1024Html' : function(a,b) {
			if(0==a)return"0 Bytes";
			var c=1024, d=b||2,f=Math.floor(Math.log(a)/Math.log(c)),
			e=[["B","Bytes"],["KB","Kilobytes"],["MB","Megabytes"],["GB","Gigabytes"],["TB","Terabytes"],["PB","Petabytes"],["EB","Exabytes"],["ZB","Zettabytes"],["YB","Yottabytes"]];
			return "<span>"+parseFloat((a/Math.pow(c,f)).toFixed(d))+"</span><span aria-label=\""+e[f][1]+"\">"+e[f][0]+"</span>";
		},
		'bytes1000' : function(a,b) {if(0==a)return"0 Bytes";var c=1000,d=b||2,e=["Bytes","KB","MB","GB","TB","PB","EB","ZB","YB"],f=Math.floor(Math.log(a)/Math.log(c));return parseFloat((a/Math.pow(c,f)).toFixed(d))+" "+e[f]
		}
	};

	//USAGE
	var count1 = new CountDown({
		'element': document.querySelector("[data-countdown-init]"),
		'format' : 'bytes1024Html',
		'runtime' : 2, //animation framecount
		'easing': true, //rate of slowdown to divide speed
		'idelay' : 2000, //initial animation delay
		'decimal': 2 //decimal count
	});
	count1.init();

	//set random listeners
	count1.el.addEventListener('eventCountdownStop', function(evt) {
		console.log('stopped');
	}, false);
	//'eventCountdownInit'
	//'eventCountdownStart'
	//'eventCountdownStop'
	//'eventCountdownChange'

	//SINGLE VALUE COUNT
	//count1.countStart({'newNum' : 9869876987765});
</script>

</body>
</html>
